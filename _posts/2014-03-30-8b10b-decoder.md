---
layout: post
title: "8B/10B解码器设计——文献阅读"
description: ""
category: "Tech"
tags: ["Verilog", "Paper"]
---
{% include JB/setup %}

阅读文章总结
============

基于逻辑设计的光纤通信8B/10B编解码方法研究
---------------------------------------------------------

### 编码思路

<img src="/assets/image/decoder_1/fig1_LogicBaseFiber_Encoder.jpg" alt="logicbasefiberen" style="width: 300px;"/>

1.  分成3B和5B两部分编码。根据码表分成RD+和RD-两列分别通过纯逻辑方式编码，既一次编码输出两组码。

2.  通过C1、C2控制单元取反，获得两组码字。这样整个编码的逻辑复杂度对于5B来说只有32个表达式和一个控制位。

3.  3B编码基本和5B相同，但是重点分析了111的情况。当RD+且5B为01011、01101、01110时，4B编码由0001变为1000;当RD-且5B为10100、10010、10001时，4B编码由1110变为0111。

4.  RD控制由控制模块完成：初始RD -> 6B选择 -> 新RD ->
    4B选择 -> 新RD -> 6B选择。

### 解码思路

<img src="/assets/image/decoder_1/fig2_LogicBaseFiber_Decoder.jpg" alt="logicbasefiberde" style="width: 300px;"/>

1.  根据游程，将6B码分成游程为2、3、4（游程即1的个数）。

    1.  游程为2、4的分别针对RD+和RD-计算逻辑表达式，通过逻辑直接解码。

    2.  游程为3的，可直接由A=a、B=b、C=c、D=d、E=e解码得出。

    3.  特别要考虑D7.x的情况，要对得到的值取反。

2.  4B解码直接由逻辑式化简得到解码。

3.  6B禁用码直接可由游程为0、1、5、6直接判断。

### 文章总结

本文思路比较清晰，但没有考虑控制字的编解码。
纯逻辑的编解码带来的问题就是竞争和冒险，还有纠错的困难。
通过游程长度来判断误码是一个比较好的思路。

一种新的8B/10B编解码硬件设计方法
-----------------------------------------------

### 编码思路

<img src="/assets/image/decoder_1/fig3_NewHardwareWay_Encoder.jpg" alt="newhardwarewayencoder" style="width: 300px;"/>

<img src="/assets/image/decoder_1/fig5_NewHardwareWay_RD.jpg" alt="newhardwarewayrd" style="width: 300px;"/>


1.  分析3B/4B码表特征，指出3B中111编码的特殊性（共有四组编码，并且和5B编码有关，总结出来的内容同@LogicBaseFiber中描述一致），建立3B/4B码表，并分成两列。

2.  分析5B/6B码表特征，根据游程长度进行编码。其中游程长为3时，一一对应；游程为2和4时，对应取反。尤其注意00111（D.7）的编码，尽管结果游程为3但还是根据RD值区分编码，注意取反。

3.  针对3B/4B提出了各种状态诸葛分析的思路，核心还是查表，并没有结合RD本身在5B/6B至3B/4B联系之间的转换，而是整体考虑。

4.  最终由控制模块，给出异或信号来确定取反情况，核心是多路选择器亦即查表。

### 解码思路

<img src="/assets/image/decoder_1/fig4_NewHardwareWay_Decoder.jpg" alt="newhardwarewaydecoder" style="width: 300px;"/>


1.  通过解码表对输出信号解码，可以认为采用case语句对应输出，由于合法的码数量十分有限，这种方法更加清晰高效。

2.  4B许用码组为14个，6B许用码组为46个。分别判断以下几项用于确定输入的码组是否合法。

    1.  分别判断4B和6B码组是否合法。

    2.  判断整个10B码组是否合法（需要结合RD分析）。

    3.  对控制码组进行判断。

3.  通过输入码组计算RD进一步判断是否为许用码组。

### 文章总结

本文的思路相对混乱，对于编解码都采用了查表的方法（编码中的查表，解码中的“CASE”）。
差错控制的思路比较好，但是略显复杂，还需要结合编码的特性来判断错误。
编码中的RD信号是通过全局来控制，和各个分组编码模块无关。

8B/10B解码器设计
------------------------------

### 解码思路

<img src="/assets/image/decoder_1/fig6_DecoderDesign_Decoder.jpg" alt="decoderdesigndecoder" style="width: 300px;"/>

1.  本解码器先判断输入码的合法性，输出相应的错误类型，最后对合法的码字解码。

2.  解码器主要分为以下几个模块。

    1.  通路选择电路

    2.  数据解码电路：真值表化简后，通过逻辑对数据码字进行直接解码。

    3.  特殊字符判定电路（K）：10B直接判断是否属于控制字。

    4.  特殊字符解码电路（K）：解码方法类似于数据解码。

    5.  数据极性运算电路

    6.  校验运算电路

    7.  违规类型判定电路

3.  针对K28.x和K.x.7几个特殊字符的判定比较简单。K28.x的6B部分只可能是001111或110000;K.x.7的4B部分只可能是1000或0111。这样的组合在数据字中是绝对不会出现的。这对快速判断是否为控制字提供了方便。

4.  本文将解码错误类型归为3种：

    1.  无效码

    2.  极性交替错误

    3.  PLL失锁

### 文章总结

本文只介绍了解码方法，并且是通过逻辑电路实现的解码。
解码具体的分为数据和控制两个方面，通过相应的电路进行解码。
此类解码器有着较好的差错控制，可以针对不同情况输出错误类型。

A DC-Balanced, Partitioned-Block, 8B/10B Transimission Code
------------------------------------------------------------------------

本文是最早提出8B/10B编码思路的文章。

### 8B/10B编码本质

8B/10B编码其实是一种固定长的编码，基本指标为：

1.  s=8：信息为8位。

2.  w=10: 编码输出为10位。

3.  d=0,k=4: 最长连0或连1为5位。

4.  v=6: DSV最大为6。

5.  是一种直流平衡的码。

为满足以上指标，所以才有了复杂的编码过程，和一些特殊的码字选取。

### 编码思路

将8B码拆分成3B（FGH）和5B（ABCDE），分别对其编码，3B编为ghij，5B编为abcdef。
为保证编码的直流平衡，引入了RD（Running Disparty）的概念，通过变化RD的值来确定下一码字的选取。
最后加上控制码字，在以上思路中加入了K位作为额外的控制位，引出一系列控制字，相应的也有其编码方法，思路同上。

#### 5B/6B

6B编码为保证码字均衡，优先从64种码字中选取均衡的码字，共有20种。
而为了保证v=6，对一对均衡的码字采取特殊方法（111000和000111，即D.7.x）结合D/K.x.3，消除了游程为6的情况。
所以，去除这种特殊情况，一一对应的编码方式有18种，这些对应编码是不需要考虑RD值的。

在考虑RD为正、负的情况，即游程为2或4的情况。
余下的14种信息码，对应28种6B码，没中码字对应互补的一对编码。
当RD为正时，选择游程为2的6B码，并使RD反转为RD-；
当RD为负时，选择游程为4的6B码，并使RD反转为RD+。

特殊情况，当输入为D.7.x时，当RD-时选择111000，当RD+时选择000111，这种情况是算在14种需要转换的码字里面的。

最后是控制字，关系到6B编码的控制字，除了K.28.x区别于D.28.x，K.23、K.27、K.29、K.30都与数字编码相同。
K.28的编码是特殊的，当RD-时输出001111，RD+时输出110000，并对相应RD反转。

#### 3B/4B

3B/4B的编码更加简单，共4种平衡码，是不需要对相应RD反转的。

着重考虑D.x.7的情况，为保证数据字eifgh的游程不超过5。
实际上的D.x.7编码有4种，其规则如下：

1.  正常情况下，RD-时输出1110，RD+时输出0001，并反转RD。

2.  当作为控制字时，仅有五种情况（K.23.7、K.27.7、K.28.7、K.29.7、K.30.7），并且和5B/6B有关，RD-时输出0111，RD+时输出1000，并反转RD。

3.  正如关于光纤的文章中提到的特殊情况。RD-并且为D.17.7、D.18.7、D.20.7，输出为1000，RD-并且为D.11.7、D.13.7、D.14.7，输出为0111，并且反转RD。

综合以上就完成了所有的编码工作，这对解码的提供了可行的思路。

### 解码思路

1.  文章采用纯逻辑思路对4B、6B分别进行解码。具体的逻辑式在文中有详细的表达式，以表格形式列出，处理了所有的可能的正确码字。

2.  解码模块里还计算了编码的RD值，用以校验解码的正确性，但是不参与解码。

文章的解码思路并没有用到RD，实际上可以让RD参与到解码过程中。

### 文章总结

1.  作为最早提出8B/10B编码思路的文章，由于年代较早，给出的是纯逻辑的编解码思路。

2.  针对几种特殊情况的处理给出了合理的解释。

3.  本文基本描述了该类型编码的起源，以及选择码字的思路，对于理解为何产生这样的编码很有帮助。

4.  纯逻辑电路有很高的参考价值，但由于存在不可避免的竞争和冒险，而且逻辑过于复杂，差错比较困难。

5.  具体的实现，作者以根据本文申请了US专利，专利号:4486739。

Implementing an 8B/10B Encoder/Decoder for Gigabit Ethernet in the Actel SX FPGA Family
-------------------------------------------------------------------------------------------------

### 本文核心

1.  基于1983年文章的编码思路，用FPGA实现8B/10B编解码。

2.  本文为适应千兆以太网传输，同时为了适应Actel的FPGA性能，对时钟、复位等结构做了详细分析。

3.  解码部分采用了流水结构以保证速度。

4.  解码部分应用的还是逻辑解码思路，部署了comma检测，及差错功能。

### 编码思路

#### ENC\_K

本模块作为控制信息的编码模块。包括以下功能：

1.  K编码选通功能。

2.  K字检错功能。

3.  K字4B、6B编码。

4.  K字的RD反转标记。

5.  特殊字的编码控制，即IBM文中的D.x.7特殊编码控制。

#### ENC\_D

本模块作为数据信息的编码模块。
通过查表（3B/4B表，5B/6B表），直接解码，由下一级根据情况进行反转。

#### ENC\_FLIP

本模块主要负责控制信息码的反转，以及RD的反转，将反转信息输入下一级以便反转。
此处的反转控制先考虑5B的情况来决定4B的反转，在一个模块里完成两者同步反转。

### 解码思路

1.  使用CASE直接解码6B。

2.  4B解码与10B数据相关，对控制字特别关注，余下的也采用CASE直接解码。

3.  控制信息检测条件：

    1.  RD+：iedc=0000即为K.28.x

    2.  RD-：iedc=1111即为K.28.x

    3.  RD+：jhgfie=010111即为K.23.7、K.27.7、K.30.7

    4.  RD-：jhgfie=101000即为K.23.7、K.27.7、K.30.7

4.  非法码检测根据IBM一文中所描述的一系列逻辑判断进行检测。

5.  comma检测条件:

    1.  001111XXXX

    2.  110000XXXX

### 文章总结

1.  本文设计功能全面，基本按照IBM文章思路进行编解码。采用查两张小表及特殊控制进行编码。

2.  解码思路以逻辑为主，多采用CASE。由于状态数较少，所以易于实现。接收重点在于控制字检测和comma检测。结合RD计算，用于检错。

3.  编码采用流水结构，速度较快。

新解码器的设计
==============

解码思路
--------

通过对上述文章编解码方式的理解分析，可以发现编码的方式比较多样，但解码仍主要停留在通过逻辑的方式。

#### Running Disparty

在所有文章的解码体系中，RD值仅作为差错检测，我觉得这是一种浪费，如果通过RD来进行解码，可以更好的利用现有的码表。

#### comma检测

comma检测仅在Actel一文中提到，作为解码器一个重要模块。我认为comma不但可以作为Byte同步，也可以用来获取当前编码器输出的RD状态，可谓一举两得。

#### 数据字解码

在获知当前RD状态的前提下，根据RD对输入码字取反，CASE条件就可以进一步化简。
整张解码用表就可以缩小一半，一方面节约了芯片面积额，一方面提高了解码效率。
由IBM文章中编码原理分析可知，对于均衡码的解码其实非常简便，只需要输出其低5或3位。

结合以上信息，只需要设计一个均衡码判断电路，就可以快速选择是否通过查表解码。

#### 控制字解码

对于控制信息，由Actel文章中中提到的控制信息检测可以发现，通过RD和固定位置的比特判断就可以区分该码字是否为控制字，并且确定是哪一类控制字(K.28.x还是K.23.7、K.27.7、K.29.7、K.30.7)。
在分析编码可知，控制字的3B或5B部分的编码规则同数据字是相同的。那么就可以“借用”数据字的解码部分来对控制字部分解码，准确输出控制码字。

具体模块功能描述
----------------

### 第一级，预处理级

#### comma检测

根据输入10B数据判断是否为comma信号，同时判断其RD。有以下伪代码：
```
if abcdeifghj==0011111001|0011111010|0011111000
comma=1;RD=0;
else if abcdeifghj==1100000110|1100000101|1100000111
comma=1;RD=1;
else
comma=0;RD=0;
endif
```

#### K检测

根据输入的10B数据判断是否是控制信号。有以下伪代码：
```
if iedc==1111|0000
K.28.x=1;K.x.7=0;
else if jhgfie==010111|101000
K.28.x=0;K.x.7=1;
else
K.28.x=0;K.x.7=0;
endif
```

#### 6B和4B平衡检测

即分别输出6B和4B是否平衡。有以下伪代码[^1]：
```
if RL(6B)==3
Balance_6B=1;
else
Balance_6B=0;
endif

if RL(4B)==2
Balance_4B=1;
else
Balance_4B=0;
endif
```

### 第二级，解码级

#### 解码表输入级

根据RD情况，对输入码字进行反转。伪代码如下：
```
if RD==1
6B=6B;
else
6B=~6B;
endif

RD_6=RD|Balance_6B
if RD_6==1
4B=4B;
else
4B=~4B;
endif
```

#### 6B/5B和4B/3B解码级

根据解码表对输入码字解码。解码表中存的查找项均为RD为正时的解码，根据输入输出解码结果。

#### 直接输出或解码输出选择级

根据码字平衡与否选择是直接输出低五位还是输出查表解码后的结果。

#### 控制字输出或数据字输出选择级

根据K.x.7和K.28.x两位，选择输出控制字还是数据字。伪代码如下：

```
if K.x.7==1
8B=5B+111;K=1;
else if K.28.x==1
8B=00111+3B;K=1;
else
8B=5B+3B;K=0;
endif
```

总结
====

经过阅读一些论文后，对于8B/10B编码的原理有了一定的认识。
并通过编码的思路尝试设计解码电路，初步设计出了根据查表的解码方法，但并未经过验证，细节上存在很多问题需要解决。
比如说时序的问题、复杂性的问题等等。

[^1]: 其中RL表示游程长度计算，即1的个数。下同。
