---
layout: post
title: "8B/10B解码器设计——文献阅读"
description: ""
category: "Tech"
tags: ["Verilog", "Paper"]
---
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
{% include JB/setup %}

阅读文章总结
============

基于逻辑设计的光纤通信8B/10B编解码方法研究@LogicBaseFiber
---------------------------------------------------------

### 编码思路

![编码器](/assets/image/decoder_1/fig1_LogicBaseFiber_Encoder.jpg )

1.  分成3B和5B两部分编码。根据码表分成$RD+$和$RD-$两列分别通过纯逻辑方式编码，既一次编码输出两组码。

2.  通过$C1$、$C2$控制单元取反，获得两组码字。这样整个编码的逻辑复杂度对于$5B$来说只有32个表达式和一个控制位。

3.  $3B$编码基本和$5B$相同，但是重点分析了$111$的情况。当$RD+$且$5B$为$01011$、$01101$、$01110$时，$4B$编码由$0001$变为$1000$;当$RD-$且$5B$为$10100$、$10010$、$10001$时，$4B$编码由$1110$变为$0111$。

4.  $RD$控制由控制模块完成：初始$RD$ $\to$ $6B$选择 $\to$ 新$RD$ $\to$
    $4B$选择 $\to$ 新$RD$ $\to$ $6B$选择。

### 解码思路

![编码器](/assets/image/decoder_1/fig2_LogicBaseFiber_Decoder.jpg )

1.  根据游程，将$6B$码分成游程为$2$、$3$、$4$（游程即$1$的个数）。

    1.  游程为$2$、$4$的分别针对$RD+$和$RD-$计算逻辑表达式，通过逻辑直接解码。

    2.  游程为$3$的，可直接由$A=a$、$B=b$、$C=c$、$D=d$、$E=e$解码得出。

    3.  特别要考虑$D7.x$的情况，要对得到的值取反。

2.  $4B$解码直接由逻辑式化简得到解码。

3.  $6B$禁用码直接可由游程为$0$、$1$、$5$、$6$直接判断。

### 文章总结

本文思路比较清晰，但没有考虑控制字的编解码。
纯逻辑的编解码带来的问题就是竞争和冒险，还有纠错的困难。
通过游程长度来判断误码是一个比较好的思路。

一种新的8B/10B编解码硬件设计方法@NewHardwareWay
-----------------------------------------------

### 编码思路

![编码器](/assets/image/decoder_1/fig3_NewHardwareWay_Encoder.jpg )

![$RD$寄存器状态图](/assets/image/decoder_1/fig5_NewHardwareWay_RD.jpg )

1.  分析$3B/4B$码表特征，指出3B中$111$编码的特殊性（共有四组编码，并且和$5B$编码有关，总结出来的内容同@LogicBaseFiber中描述一致），建立$3B/4B$码表，并分成两列。

2.  分析$5B/6B$码表特征，根据游程长度进行编码。其中游程长为$3$时，一一对应；游程为$2$和$4$时，对应取反。尤其注意$00111$（$D.7$）的编码，尽管结果游程为$3$但还是根据$RD$值区分编码，注意取反。

3.  针对$3B/4B$提出了各种状态诸葛分析的思路，核心还是查表，并没有结合$RD$本身在$5B/6B$至$3B/4B$联系之间的转换，而是整体考虑。

4.  最终由控制模块，给出异或信号来确定取反情况，核心是多路选择器亦即查表。

### 解码思路

![解码器](/assets/image/decoder_1/fig4_NewHardwareWay_Decoder.jpg )

1.  通过解码表对输出信号解码，可以认为采用case语句对应输出，由于合法的码数量十分有限，这种方法更加清晰高效。

2.  $4B$许用码组为$14$个，$6B$许用码组为$46$个。分别判断以下几项用于确定输入的码组是否合法。

    1.  分别判断$4B$和$6B$码组是否合法。

    2.  判断整个$10B$码组是否合法（需要结合$RD$分析）。

    3.  对控制码组进行判断。

3.  通过输入码组计算$RD$进一步判断是否为许用码组。

### 文章总结

本文的思路相对混乱，对于编解码都采用了查表的方法（编码中的查表，解码中的“CASE”）。
差错控制的思路比较好，但是略显复杂，还需要结合编码的特性来判断错误。
编码中的$RD$信号是通过全局来控制，和各个分组编码模块无关。

8B/10B解码器设计@DecoderDesign
------------------------------

### 解码思路

![解码器](/assets/image/decoder_1/fig6_DecoderDesign_Decoder.jpg )

1.  本解码器先判断输入码的合法性，输出相应的错误类型，最后对合法的码字解码。

2.  解码器主要分为以下几个模块。

    1.  通路选择电路

    2.  数据解码电路：真值表化简后，通过逻辑对数据码字进行直接解码，类似于@LogicBaseFiber一文。

    3.  特殊字符判定电路（$K$）：$10B$直接判断是否属于控制字。

    4.  特殊字符解码电路（$K$）：解码方法类似于数据解码。

    5.  数据极性运算电路

    6.  校验运算电路

    7.  违规类型判定电路

3.  针对$K28.x$和$K.x.7$几个特殊字符的判定比较简单。$K28.x$的$6B$部分只可能是$001111$或$110000$;$K.x.7$的$4B$部分只可能是$1000$或$0111$。这样的组合在数据字中是绝对不会出现的。这对快速判断是否为控制字提供了方便。

4.  本文将解码错误类型归为$3$种：

    1.  无效码

    2.  极性交替错误

    3.  PLL失锁

### 文章总结

本文只介绍了解码方法，并且是通过逻辑电路实现的解码。
解码具体的分为数据和控制两个方面，通过相应的电路进行解码。
此类解码器有着较好的差错控制，可以针对不同情况输出错误类型。

A DC-Balanced, Partitioned-Block, 8B/10B Transimission Code@ClassicPaper
------------------------------------------------------------------------

本文是最早提出$8B/10B$编码思路的文章。

### $8B/10B$编码本质

$8B/10B$编码其实是一种固定长的编码，基本指标为：

1.  $s=8$：信息为$8$位。

2.  $w=10$: 编码输出为$10$位。

3.  $d=0$,$k=4$: 最长连$0$或连$1$为$5$位。

4.  $v=6$: DSV最大为$6$。

5.  是一种直流平衡的码。

为满足以上指标，所以才有了复杂的编码过程，和一些特殊的码字选取。

### 编码思路

将$8B$码拆分成$3B$（$FGH$）和$5B$（$ABCDE$），分别对其编码，$3B$编为$ghij$，$5B$编为$abcdef$。
为保证编码的直流平衡，引入了$RD$（$Running Disparty$）的概念，通过变化$RD$的值来确定下一码字的选取。
最后加上控制码字，在以上思路中加入了$K$位作为额外的控制位，引出一系列控制字，相应的也有其编码方法，思路同上。

#### $5B/6B$

$6B$编码为保证码字均衡，优先从$2^6=64$种码字中选取均衡的码字，共有$C_6^3=20$种。
而为了保证$v=6$，对一对均衡的码字采取特殊方法（$111000$和$000111$，即$D.7.x$）结合$D/K.x.3$，消除了游程为$6$的情况。
所以，去除这种特殊情况，一一对应的编码方式有18种，这些对应编码是不需要考虑$RD$值的。

在考虑$RD$为正、负的情况，即游程为$2$或$4$的情况。
余下的$14$种信息码，对应$28$种$6B$码，没中码字对应互补的一对编码。
当$RD$为正时，选择游程为$2$的$6B$码，并使$RD$反转为$RD-$；
当$RD$为负时，选择游程为$4$的$6B$码，并使$RD$反转为$RD+$。

特殊情况，当输入为$D.7.x$时，当$RD-$时选择$111000$，当$RD+$时选择$000111$，这种情况是算在$14$种需要转换的码字里面的。

最后是控制字，关系到$6B$编码的控制字，除了$K.28.x$区别于$D.28.x$，$K.23$、$K.27$、$K.29$、$K.30$都与数字编码相同。
$K.28$的编码是特殊的，当$RD-$时输出$001111$，$RD+$时输出$110000$，并对相应$RD$反转。

#### $3B/4B$

$3B/4B$的编码更加简单，共$C_4^2=4$种平衡码，是不需要对相应$RD$反转的。

着重考虑$D.x.7$的情况，为保证数据字$eifgh$的游程不超过$5$。
实际上的$D.x.7$编码有$4$种，其规则如下：

1.  正常情况下，$RD-$时输出$1110$，$RD+$时输出$0001$，并反转$RD$。

2.  当作为控制字时，仅有五种情况（$K.23.7$、$K.27.7$、$K.28.7$、$K.29.7$、$K.30.7$），并且和$5B/6B$有关，$RD-$时输出$0111$，$RD+$时输出$1000$，并反转$RD$。

3.  正如@LogicBaseFiber中提到的特殊情况。$RD-$并且为$D.17.7$、$D.18.7$、$D.20.7$，输出为$1000$，$RD-$并且为$D.11.7$、$D.13.7$、$D.14.7$，输出为$0111$，并且反转$RD$。

综合以上就完成了所有的编码工作，这对解码的提供了可行的思路。

### 解码思路

1.  文章采用纯逻辑思路对$4B$、$6B$分别进行解码。具体的逻辑式在文中有详细的表达式，以表格形式列出，处理了所有的可能的正确码字。

2.  解码模块里还计算了编码的$RD$值，用以校验解码的正确性，但是不参与解码。

文章的解码思路并没有用到$RD$，实际上可以让$RD$参与到解码过程中。

### 文章总结

1.  作为最早提出$8B/10B$编码思路的文章，由于年代较早，给出的是纯逻辑的编解码思路。

2.  针对几种特殊情况的处理给出了合理的解释。

3.  本文基本描述了该类型编码的起源，以及选择码字的思路，对于理解为何产生这样的编码很有帮助。

4.  纯逻辑电路有很高的参考价值，但由于存在不可避免的竞争和冒险，而且逻辑过于复杂，差错比较困难。

5.  具体的实现，作者以根据本文申请了US专利，专利号:4486739。

Implementing an 8B/10B Encoder/Decoder for Gigabit Ethernet in the Actel SX FPGA Family@ActelNote
-------------------------------------------------------------------------------------------------

### 本文核心

1.  基于1983年文章的编码思路，用FPGA实现$8B/10B$编解码。

2.  本文为适应千兆以太网传输，同时为了适应Actel的FPGA性能，对时钟、复位等结构做了详细分析。

3.  解码部分采用了流水结构以保证速度。

4.  解码部分应用的还是逻辑解码思路，部署了comma检测，及差错功能。

### 编码思路

#### $ENC\_K$

本模块作为控制信息的编码模块。包括以下功能：

1.  $K$编码选通功能。

2.  $K$字检错功能。

3.  $K$字$4B$、$6B$编码。

4.  $K$字的$RD$反转标记。

5.  特殊字的编码控制，即@ClassicPaper中的$D.x.7$特殊编码控制。

#### $ENC\_D$

本模块作为数据信息的编码模块。
通过查表（$3B/4B$表，$5B/6B$表），直接解码，由下一级根据情况进行反转。

#### $ENC\_FLIP$

本模块主要负责控制信息码的反转，以及$RD$的反转，将反转信息输入下一级以便反转。
此处的反转控制先考虑$5B$的情况来决定$4B$的反转，在一个模块里完成两者同步反转。

### 解码思路

1.  使用CASE直接解码$6B$。

2.  $4B$解码与$10B$数据相关，对控制字特别关注，余下的也采用CASE直接解码。

3.  控制信息检测条件：

    1.  $RD+$：$iedc=0000$即为$K.28.x$

    2.  $RD-$：$iedc=1111$即为$K.28.x$

    3.  $RD+$：$jhgfie=010111$即为$K.23.7$、$K.27.7$、$K.30.7$

    4.  $RD-$：$jhgfie=101000$即为$K.23.7$、$K.27.7$、$K.30.7$

4.  非法码检测根据@ClassicPaper中所描述的一系列逻辑判断进行检测。

5.  comma检测条件:

    1.  $001111XXXX$

    2.  $110000XXXX$

### 文章总结

1.  本文设计功能全面，基本按照IBM文章思路进行编解码。采用查两张小表及特殊控制进行编码。

2.  解码思路以逻辑为主，多采用CASE。由于状态数较少，所以易于实现。接收重点在于控制字检测和comma检测。结合$RD$计算，用于检错。

3.  编码采用流水结构，速度较快。

新解码器的设计
==============

解码思路
--------

通过对上述文章编解码方式的理解分析，可以发现编码的方式比较多样，但解码仍主要停留在通过逻辑的方式。
在@LogicBaseFiber、@NewHardwareWay和@ClassicPaper中采用的是纯逻辑解码方式；在@DecoderDesgin和@ActelNote这两篇文章中采用的是多路选择器的方式。

#### Running Disparty

在所有文章的解码体系中，$RD$值仅作为差错检测，我觉得这是一种浪费，如果通过$RD$来进行解码，可以更好的利用现有的码表。

#### comma检测

comma检测仅在@ActelNote一文中提到，作为解码器一个重要模块。我认为comma不但可以作为Byte同步，也可以用来获取当前编码器输出的$RD$状态，可谓一举两得。

#### 数据字解码

在获知当前$RD$状态的前提下，根据$RD$对输入码字取反，CASE条件就可以进一步化简。
整张解码用表就可以缩小一半，一方面节约了芯片面积额，一方面提高了解码效率。
由@ClassicPaper中编码原理分析可知，对于均衡码的解码其实非常简便，只需要输出其低$5$或$3$位。

结合以上信息，只需要设计一个均衡码判断电路，就可以快速选择是否通过查表解码。

#### 控制字解码

对于控制信息，由@ActelNote中提到的控制信息检测可以发现，通过$RD$和固定位置的比特判断就可以区分该码字是否为控制字，并且确定是哪一类控制字($K.28.x$还是$K.23.7$、$K.27.7$、$K.29.7$、$K.30.7$)。
在分析编码可知，控制字的$3B$或$5B$部分的编码规则同数据字是相同的。那么就可以“借用”数据字的解码部分来对控制字部分解码，准确输出控制码字。

具体模块功能描述
----------------

### 第一级，预处理级

#### comma检测

根据输入$10B$数据判断是否为comma信号，同时判断其$RD$。有以下伪代码：

```
if $abcdeifghj==0011111001|0011111010|0011111000$\
$comma=1;RD=0;$\
else if $abcdeifghj==1100000110|1100000101|1100000111$\
$comma=1;RD=1;$\
else\
$comma=0;RD=0;$\
endif
```

#### K检测

根据输入的$10B$数据判断是否是控制信号。有以下伪代码：

<span>if</span> $iedc==1111|0000$\
$K.28.x=1;K.x.7=0;$\
<span>else if</span> $jhgfie==010111|101000$\
$K.28.x=0;K.x.7=1;$\
<span>else</span>\
$K.28.x=0;K.x.7=0;$\
<span>endif</span>

#### $6B$和$4B$平衡检测

即分别输出$6B$和$4B$是否平衡。有以下伪代码[^1]：

```
if $RL(6B)==3$\
$Balance\_6B=1;$\
else\
$Balance\_6B=0;$\
endif

if $RL(4B)==2$\
$Balance\_4B=1;$\
else\
$Balance\_4B=0;$\
endif
```

### 第二级，解码级

#### 解码表输入级

根据$RD$情况，对输入码字进行反转。伪代码如下：

```
if $RD==1$\
$6B=6B;$\
else\
$6B=~6B;$\
endif

=$RD\_6=RD|Balance\_6B$\
if $RD\_6==1$\
$4B=4B;$\
else\
$4B=~4B;$\
endif
```

#### $6B/5B$和$4B/3B$解码级

根据解码表对输入码字解码。解码表中存的查找项均为$RD$为正时的解码，根据输入输出解码结果。

#### 直接输出或解码输出选择级

根据码字平衡与否选择是直接输出低五位还是输出查表解码后的结果。

#### 控制字输出或数据字输出选择级

根据$K.x.7$和$K.28.x$两位，选择输出控制字还是数据字。伪代码如下：

``
if $K.x.7==1$\
$8B=5B+111;K=1;$\
else if $K.28.x==1$\
$8B=00111+3B;K=1;$\
else\
$8B=5B+3B;K=0;$\
endif
``

解码表
------


    Name     $RD$   $abcdei$   $ABCDE$
  -------- ------ ---------- ---------
   $D.0$      $+$   $011000$   $00000$
   $D.1$      $+$   $100010$   $10000$
   $D.2$      $+$   $010010$   $01000$
   $D.4$      $+$   $001010$   $00100$
   $D.7$      $+$   $000111$   $11100$
   $D.8$      $+$   $000110$   $00010$
   $D.15$     $+$   $101000$   $11110$
   $D.16$     $+$   $100100$   $00001$
   $D.23$     $+$   $000101$   $11101$
   $D.24$     $+$   $001100$   $00011$
   $D.27$     $+$   $001001$   $11011$
   $D.29$     $+$   $010001$   $10111$
   $D.30$     $+$   $100001$   $01111$
   $D.31$     $+$   $010100$   $11111$

    Name      $RD$   $fghj$   $FGH$
  --------- ------ -------- -------
   $D.x.0$     $+$   $0100$   $000$
   $D.x.3$     $+$   $0011$   $110$
   $D.x.4$     $+$   $0010$   $001$
   $D.x.7$     $+$   $0001$   $111$
   $D.x.7$     $+$   $1000$   $111$


总结
====

经过阅读一些论文后，对于$8B/10B$编码的原理有了一定的认识。
并通过编码的思路尝试设计解码电路，初步设计出了根据查表的解码方法，但并未经过验证，细节上存在很多问题需要解决。
比如说时序的问题、复杂性的问题等等。

[^1]: 其中$RL$表示游程长度计算，即$1$的个数。下同。
