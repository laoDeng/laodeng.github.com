---
layout: post
title: "Serdes接口中8B/10B解码器设计初步结果"
description: ""
category: "Tech"
tags: ["Verilog", "Paper"]
---
{% include JB/setup %}

根据SERDES协议要求初步完成了解码器的设计，同时根据以太网协议完成了较为可靠的编码生成电路。
这些电路的代码都包含在附件中，每个文件的作用及使用方法，详见README文档。
本文正文主要展示仿真结果及相关设计思路。

编码器
======

编码器采用的是最简单的查大表的方法。
与此前不同的是，本次的码表完全拷贝了以太网协议中的码表，保证了其可靠性。
又根据SERDES协议内容，去除了一些没有用到的控制字。
并且有一些很粗糙的设计，完全已能够运行并且正确输出为目的。

<img src="/assets/image/decoder_2/fig1_Encoder_tb.png" alt="fig1" style="width: 700px;"/>

根据手工判断，编码无误。

解码器
======

解码器主要分成两部分，RD检测和查表解码，最终组成解码器，并且能够输出错误类型和控制字。

<img src="/assets/image/decoder_2/fig2_Decoder_tb.png" alt="fig1" style="width: 700px;"/>

在解码器中采用同上图相同的输入，对比可得，解码正确。

RD检测
------

RD检测针对SERDES接口需求接口进行了简化，并确保RD错误能够显示。
采用了整体10B输入计算游程长度的方法进行检测，可由以下伪代码来计算RD故障。

```
if $RL == 5$[^1]
$RD_error = 0;$[^2]
else if $RD_current == RD_last$
$RD_error = 1;$
else
$RD_error = 0;$
endif
```

上述方法即判断新输入的码字是否均衡，如果均衡那么RD是不会发生错误的。
如果不均衡，码字输入前的RD值若是和现在计算出的RD是相同的，说明前面某一码字出现了误码，传播到当前码字反映出RD错误。

下面展示两种在以太网协议中作为RD故障例子的码字，在本检测电路中的检测效果。

<img src="/assets/image/decoder_2/fig3_RD_cal_tb_err_1.png" alt="fig3" style="width: 700px;"/>

可以看到，第二个输入码字101010_1011的输出RD应该为正；
第三个输入码字010101_0101的为均衡码，所以RD并不变还是为正，没有检测到错误；
第四个输入码字111010_1010的输出RD应该为正，这就与现存的RD违背。
因为RD在整个解码过程中，如果是均衡的码字就保持不变，而若是不均衡的码字就会反转。
第四个码字并不是均衡的码字但是结果RD并没有反转，所以报错。

但是其实是不是第四个码字出错了呢？并不知道。因为存在均衡码字，RD错误的精确定位就比较复杂，只能说在发生误码后之后的数个码字后会检测出错误。
所以SERDES协议上端对这种错误只报错不纠错。

<img src="/assets/image/decoder_2/fig4_RD_cal_tb_err_2.png" alt="fig4" style="width: 700px;"/>

第二种错误同理也可以解释。
但此处有所不同的是，以太网协议中是对6B和4B分别检测，所以他能够较快的发现RD错误。
但是我所设计的检测电路是整体检测，所以在某些情况下并不能及时的发现错误。
在电路复杂度和检错灵敏度方面只能取一。

查表解码
--------

查表解码电路就是大多数论文中除了逻辑硬解码之外的主要解码方式，采用CASE语句将所有可能的情况录入，直接输出结果。
同时，也对码字进行In Table判断。
此处的解码并不考虑RD是否合理，而是只要输入的码字能够被找到就是正确的，如果没有找到，就报错。

结合SERDES接口中的情况，我的设计中并没有另外设计控制字检测模块，而是将其融入了解码当中。
由于SERDES只用到了5个控制字，并且全为K.28.x。
分析这些控制字可以发现，K.28的检测是非常容易的，所以只要在6B到5B解码部分重点关注下K.28即可直接判断是否为控制字。

这样解码固然方便，但也是要考虑到SERDES协议并没有用到所有的K.28控制字。
所以为K.28控制字的码固然会被作为控制字输出，但是也有可能会引起Not In
Table Error。 针对这几个可能的误码在4B到3B解码中做了相应的处理。
判断方法是，如果6B部分判断为控制字，则4B部分会排除那些非SERDES控制字的码字，视作Not
In Table Error。

同样的用编码器的部分输出作为解码输入进行仿真。

<img src="/assets/image/decoder_2/fig5_tab_decode_tb.png" alt="fig5" style="width: 700px;"/>

编解码器结合仿真
================

最后，将两部分模块结合起来进行仿真查看结果，以检验效果。
对编码器输出做一个时钟周期的延迟，再对编码器出入。

<img src="/assets/image/decoder_2/fig6_combine_tb_increase.png" alt="fig6" style="width: 700px;"/>

其中num_5B_in和num_3B_in表示输入编码器的值，num_5B_out和num_3B_out表示输出解码器的值。
可以发现解码结果和输入相差一个时钟周期，证明解码正确。
RD_err、NIT_err及K_bit分别表示RD error、Not in table
error及控制字指示。

由于输入编码没有设计控制字部分，没有增加干扰和控制字，所以这些指示位均为低。

<img src="/assets/image/decoder_2/fig7_combine_tb_rand.png" alt="fig7" style="width: 700px;"/>

上图中所展示的是，随机输入数据字的联合仿真，可以发现解码依然正确。

<img src="/assets/image/decoder_2/fig8_combine_tb_rand_k.png" alt="fig8" style="width: 700px;"/>

上图中所展示的是，随机输入数据字，并穿插随机控制字的联合仿真。
可以发现解码依然正确[^3]，并且编码器的K符号和解码器的K_bit刚好相差一个时钟周期显示，说明K字解码正确。

总结
====

总体的编写代码使用了一天不到时间，但是调试及纠错耗费了整整两天，才得到正确的结果。
尤其是时序的问题，在编写硬件代码时尤为重要，错误的时序会产生莫名其妙的错误，这些需要在不断的编写的调试中慢慢积累经验。

通过仿真得到的结果发现，在RTL级下电路的主要功能已经能够实现，下一步考虑优化结构做一些改进。

[^1]: 此处的RL指的是10B数据游程长度，下同。

[^2]: 此处用0表示RD正常，1表示RD不正常，下同。

[^3]: 控制字需要观察下方encode_10B两行，上一行表示的是编码器输出的码字，下一行表示的是解码器得到的码字。
